Objects
-------

### ObjectClass

Zetbox knows four kinds of Types, all derived from *DataType*:

[[!table header="no" data="""
ObjectClass    | Type for Zetbox Object Classes
Interface      | Type for Zetbox Interfaces
Enumeration    | Type for Zetbox Enumerations
CompoundObject | Type for Zetbox Object Classes
"""]]

#### DataType

This is the abstract base class for all Zetbox Types. It provides the
necessary infrastructure to describe a Type.

[[!format cs """
public interface DataType
{
    string Name; 
	string Description;

    IList<Property> Properties; 
	ICollection<Method> Methods;

    Icon DefaultIcon; 
	ICollection<InstanceConstraint> Constraints;
}
"""]

[[!table header="no" data="""
Name
|   The name of the *DataType*. Note that this name has to be a valid
    C\# name. A *Constraint* protects this.

Description
|   Each Type should have a description. This description is used for
    documentation purposes.

Properties
|   Each Type can have Properties (except *Enumeration*)

Methods
|   Each Type can have Methods (except *Enumeration*)

DefaultIcon
|   Each *DataType* can have a default icon

Constraints
|   A *Constraint* checks the validity of an instance. If any constraint
    throws an error nothing will be committed.
"""]]

#### ObjectClass

*ObjectClass* is *the* defining class for Zetbox Objects.

public interface ObjectClass : DataType

ObjectClass BaseObjectClass; ICollection\<Interface\>
ImplementsInterfaces;

string TableName;

bool IsAbstract; bool IsFrozenObject; bool IsSimpleObject;

ViewModelDescriptor DefaultViewModelDescriptor; ControlKind
RequestedKind;

ICollection\<AccessControl\> AccessControlList;

IsAbstract
:   
IsSimpleObject
:   The *ObjectClass* is marked as a simple, non complex object. Set it
    to true for all classes that have no inheritance and less enought
    and simple properties to edit them in grids and/or lists. This will
    prevent all list view models from opening such an object directly.
    Also the *ObjectBrowser* will not provide any interface.

### Relation

A *Relation* defines the relationship between two Objects. Every Object
can have zero or more *Relations*.

An example of a *Relation* is the relation between *Project* and
*Tasks*. One *Project* can have zero or more *Tasks*. One *Tasks* must
have a *Project*.

[ht]

![image](images/Rel_1_n_Project_Tasks.jpg) [example~f~or~r~elation]

### Modeling a relation

A Relation can be defined by creating an object of type *Relation* and
two *RelationEnd* objects. This can be done by

-   creating an Relation Object.

-   invoking the *Create Relation* method on an *ObjectClass* instance.

*RelationEnd* objects will be created automatically.

Relations are edited in the *Relation Editor*. The *Relation Editor* is
a custom *FullObjectView* created by us.

[ht]

![image](images/ScreenShot_Rel_Project_Task.png)
[example~f~or~e~diting~r~elation]

### Attributes of a relation

[ht]

![image](images/Rel_Attributes.png) [attributes~o~f~ar~elation]

A *Relation* has these attributes:

A text property used to describe the current relation

The *Module* which is introducing the current relation

The *StorageType* of the current relation

A verb used to name the current relation. The verb is used in
conjunction with the role names of the *RelationEnd* objects to model a
unique relation name. This relation name will be used e.g. for the
database FK Contraint name.

The *RelationEnd* A of the current relation

The *RelationEnd* B of the current relation

A *RelationEnd* has these attributes:

*Relation* object if this *RelationEnd* is the A-Side of the current
relation. Otherwise *NULL*

*Relation* object if this *RelationEnd* is the B-Side of the current
relation. Otherwise *NULL*

Specifies that the list is ordered. Applies only to lists

The *Multiplicity* of the current *RelationEnd*

An optional *Navigator*

Name of the role of the current *RelationEnd*

*ObjectClass* to which the current *RelationEnd* points

There are four *StorageTypes* defined:

The relation information is stored with the A-side database table

The relation information is stored with the B-side database table

The relation information is stored on both sides of the relations
database tables

The relation information is stored in a separate database table

There are three *Multiplicities* defined:

Optional Element (zero or one)

Required Element (exactly one)

Optional List Element (zero or more)

### 1:n Relation

A *Project* can have zero or more *Tasks*. A *Task* may have one
*Project*.

[ht]

![image](images/Rel_1_n_Project_Tasks.png) [project~t~asks~r~elation]

The *Relation* object would be:

= MergeIntoB

= has

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= false

= ZeroOrOne. If a *Task* must have a *Project* then One.

= *Navigator* to Tasks. The result would be a collection of *Tasks*
(ICollection\<Task\>)

= Project

= *Task* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= false

= ZeroOrMore

= *Navigator* to the parent *Project*. The result would be a reference
to a *Project*

= Tasks

= *Project* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_Task.png)
[editing~p~roject~t~asks~r~elation]

### n:m Relation

A *Project* can have zero or more *ProjectMembers*. A *ProjectMember*
can be assinged to zero or more *Projects*.

[ht]

![image](images/Rel_n_m_Project_Member.png) [project~m~ember~r~elation]

The *Relation* object would be:

= Seperate

= has

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= true

= ZeroOrMore.

= *Navigator* to Persons. The result would be a list of *Persons*
(IList\<Person\>)

= Projects

= *Person* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= true

= ZeroOrMore

= *Navigator* to the assigned *Projects*. The result would be a list of
*Projects* (IList\<Project\>)

= Member

= *Project* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_ProjectMember.png)
[editing~p~roject~m~ember~r~elation]

### 1:1 Relation

A *Relation* must have a *RelationEnd* A. A *RelationEnd* may have a
AParent *Relation* if it’s a A *ReleationEnd*.

[ht]

![image](images/Rel_Attributes.png) [relation~r~elationend~r~elation]

The *Relation* object would be:

= MergeIntoA

= hasA

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= false

= ZeroOrOne

= *Navigator* to *RelationEnd*. The result would be a reference to a
*RelationEnd*

= Relation

= *RelationEnd* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= true

= One

= *Navigator* to the assigned *Relation*. The result would be a
reference to a *Relation*

= A

= *Relation* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_ProjectMember.png)
[editing~r~elation~r~elationend~r~elation]

### Multiplicity and StorageType summary

|p5cm|p5cm|

\
\
 &\
A.Nav is a collection & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = ZeroOrMore\
A.Nav is a collection & B.Nav is not nullable\
Multiplicity = One & Multiplicity = ZeroOrMore\

|p5cm|p5cm|

\
\
 &\
A.Nav is nullable & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = ZeroOrOne\
A.Nav is not nullable & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = One\

|p5cm|p5cm|

\
\
 &\
A.Nav is a collection & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = ZeroOrMore\

|p5cm|p5cm|

\
\
\
\
 &\
A.Nav is nullable & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = ZeroOrOne\
A.Nav is nullable & B.Nav is not nullable\
Multiplicity = One & Multiplicity = ZeroOrOne\
A.Nav is not nullable & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = One\
A.Nav is not nullable & B.Nav is not nullable\
Multiplicity = One & Multiplicity = One\


	
### Properties

public interface Property string Name; ...

Editable in Grid
:   This is an override for the inline editing behaviour for grid and
    list controls. The default behaviour is to evaluate if the
    referenced *ObjectClass* is a simple object or not.

### Additional Metadata

The object model is intended to be very rich and provide the various
subsystems with meta data directly from the *ObjectClass*.

This section describes the various pieces of this meta data.

#### New related objects

A *CreateRelatedUseCase* describes the use case of creating a new object
related to the "current" instance. One such use case would be
e.g. "create a new *Relation* from the current ObjectClass."

Such use cases are described with *CreateRelatedUseCase* objects:

interface CreateRelatedUseCase string Label; Method Action; Relation
AffectedRelation; // optional

The *Action* will be called when the user requests an execution of this
use case. This method doesn’t take any parameters and returns the newly
created object. The infrastructure on the client will cause the returned
object to be displayed to the user. The business logic should already
have filled out the property values according to the use case. The name
of the method should start with "Create".

If the optional *AffectedRelation* is specified, one of its ends it must
match the *ObjectClass* of the *Method*. This relation can then be used
to identify controls in the UI where the action can be placed.