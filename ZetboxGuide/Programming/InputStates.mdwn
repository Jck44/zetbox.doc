States of an Input Control
--------------------------

*Input controls* are Views receiving input from the user. The following
state diagram explains the possible basic states of the underlying
*InputViewModel*:

An InputViewModel has two distinct dimensions along which it modifies
its behaviour. One is whether or not it currently has the focus[^1]. The
other dimension is whether or not there are outstanding (partial)
modifications to the Value.

B
:   The ViewModel is *blurred*. That is, it does not have the focus.
    User input will not reach the control.

F
:   The ViewModel is *focused*. That is, it has the focus. The control
    will be notified of the user’s next input.

IF
:   The ViewModel is *implicitely focused*. This states is reached by
    signalling user input without first signalling a focusing event. It
    is a convenient shortcut for Toolkits which do not track the concept
    of focus. Since this state is unaware of the user’s focus, it has to
    bubble changes to the canonically formatted Value immediately to the
    View, possibly disrupting the user’s input.

UV
:   The View should display the *unmodified Value*. This is the common
    state when no input was received or all input was processed
    successfully.

PUI
:   The View should display a *partial user input*. If the user cannot
    input a valid value atomically, the ViewModel will enter this state
    to keep track of the partial value to add more input from the user
    until a valid value is formed.

WM
:   The ViewModel is currently *writing to the Model*. Change
    notifications from the Model in this state are generated by the
    writing ViewModel and thus must be ignored locally.

There are several events that determine the actual state of the
InputViewModel.

F
:   The ViewModel receives *Focus*.

B1
:   The ViewModel looses *Focus*. Since this signals the user loosing
    interest in further editing this Value, a change in the
    FormattedValue is signalled[^2] to update the View to the canonical
    representation of the Value.

B2
:   The ViewModel looses *Focus*. Since the user has still a pending
    partial input, the ViewModel expects the user to return and continue
    editing.

MC1
:   The Model is *changed* by a third party. This might be due to
    changes from the business logic or via other ViewModels. In any case
    the View should be signalled to update its display to the new Value.

MC2
:   The Model is *changed* by a third party. The user is currently
    editing the Value, so changes there should be ignored. In most cases
    this constitutes a programming error, as no code should try to
    change values while the user is editing them.

MC3
:   The Model is *changed* by the ViewModel. The View should be
    signalled to update its display to the new Value. Since this is in
    reaction to user input, this might not display a canonicalized value

PI
:   The user enters *partial input*. The ViewModel will store this until
    the user completes or aborts[^3] her edit.

VI
:   The user enters *complete input*. The ViewModel accepts the input as
    valid and will proceed to write it back to the Model.

[^1]: usually the keyboard focus

[^2]: If the user has not modified the Value, this signalling could be
    optimized away. Since the canonical representation should always be
    on display unless the user is currently editing this is not deemed
    an issue at this time.

[^3]: Canceling is currently not supported
