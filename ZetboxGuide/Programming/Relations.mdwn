Relation
--------

A *Relation* defines the relationship between two Objects. Every Object
can have zero or more *Relations*.

An example of a *Relation* is the relation between *Project* and
*Tasks*. One *Project* can have zero or more *Tasks*. One *Tasks* must
have a *Project*.

[ht]

![image](images/Rel_1_n_Project_Tasks.jpg) [example~f~or~r~elation]

### Modeling a relation

A Relation can be defined by creating an object of type *Relation* and
two *RelationEnd* objects. This can be done by

-   creating an Relation Object.

-   invoking the *Create Relation* method on an *ObjectClass* instance.

*RelationEnd* objects will be created automatically.

Relations are edited in the *Relation Editor*. The *Relation Editor* is
a custom *FullObjectView* created by us.

[ht]

![image](images/ScreenShot_Rel_Project_Task.png)
[example~f~or~e~diting~r~elation]

### Attributes of a relation

[ht]

![image](images/Rel_Attributes.png) [attributes~o~f~ar~elation]

A *Relation* has these attributes:

A text property used to describe the current relation

The *Module* which is introducing the current relation

The *StorageType* of the current relation

A verb used to name the current relation. The verb is used in
conjunction with the role names of the *RelationEnd* objects to model a
unique relation name. This relation name will be used e.g. for the
database FK Contraint name.

The *RelationEnd* A of the current relation

The *RelationEnd* B of the current relation

A *RelationEnd* has these attributes:

*Relation* object if this *RelationEnd* is the A-Side of the current
relation. Otherwise *NULL*

*Relation* object if this *RelationEnd* is the B-Side of the current
relation. Otherwise *NULL*

Specifies that the list is ordered. Applies only to lists

The *Multiplicity* of the current *RelationEnd*

An optional *Navigator*

Name of the role of the current *RelationEnd*

*ObjectClass* to which the current *RelationEnd* points

There are four *StorageTypes* defined:

The relation information is stored with the A-side database table

The relation information is stored with the B-side database table

The relation information is stored on both sides of the relations
database tables

The relation information is stored in a separate database table

There are three *Multiplicities* defined:

Optional Element (zero or one)

Required Element (exactly one)

Optional List Element (zero or more)

### 1:n Relation

A *Project* can have zero or more *Tasks*. A *Task* may have one
*Project*.

[ht]

![image](images/Rel_1_n_Project_Tasks.png) [project~t~asks~r~elation]

The *Relation* object would be:

= MergeIntoB

= has

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= false

= ZeroOrOne. If a *Task* must have a *Project* then One.

= *Navigator* to Tasks. The result would be a collection of *Tasks*
(ICollection\<Task\>)

= Project

= *Task* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= false

= ZeroOrMore

= *Navigator* to the parent *Project*. The result would be a reference
to a *Project*

= Tasks

= *Project* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_Task.png)
[editing~p~roject~t~asks~r~elation]

### n:m Relation

A *Project* can have zero or more *ProjectMembers*. A *ProjectMember*
can be assinged to zero or more *Projects*.

[ht]

![image](images/Rel_n_m_Project_Member.png) [project~m~ember~r~elation]

The *Relation* object would be:

= Seperate

= has

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= true

= ZeroOrMore.

= *Navigator* to Persons. The result would be a list of *Persons*
(IList\<Person\>)

= Projects

= *Person* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= true

= ZeroOrMore

= *Navigator* to the assigned *Projects*. The result would be a list of
*Projects* (IList\<Project\>)

= Member

= *Project* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_ProjectMember.png)
[editing~p~roject~m~ember~r~elation]

### 1:1 Relation

A *Relation* must have a *RelationEnd* A. A *RelationEnd* may have a
AParent *Relation* if itâ€™s a A *ReleationEnd*.

[ht]

![image](images/Rel_Attributes.png) [relation~r~elationend~r~elation]

The *Relation* object would be:

= MergeIntoA

= hasA

The *RelationEnd* A object would be:

= *Relation*

= *NULL*

= false

= ZeroOrOne

= *Navigator* to *RelationEnd*. The result would be a reference to a
*RelationEnd*

= Relation

= *RelationEnd* instance of type *ObjectClass*

The *RelationEnd* B object would be:

= *NULL*

= *Relation*

= true

= One

= *Navigator* to the assigned *Relation*. The result would be a
reference to a *Relation*

= A

= *Relation* instance of type *ObjectClass*

[ht]

![image](images/ScreenShot_Rel_Project_ProjectMember.png)
[editing~r~elation~r~elationend~r~elation]

### Multiplicity and StorageType summary

|p5cm|p5cm|

\
\
 &\
A.Nav is a collection & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = ZeroOrMore\
A.Nav is a collection & B.Nav is not nullable\
Multiplicity = One & Multiplicity = ZeroOrMore\

|p5cm|p5cm|

\
\
 &\
A.Nav is nullable & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = ZeroOrOne\
A.Nav is not nullable & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = One\

|p5cm|p5cm|

\
\
 &\
A.Nav is a collection & B.Nav is a collection\
Multiplicity = ZeroOrMore & Multiplicity = ZeroOrMore\

|p5cm|p5cm|

\
\
\
\
 &\
A.Nav is nullable & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = ZeroOrOne\
A.Nav is nullable & B.Nav is not nullable\
Multiplicity = One & Multiplicity = ZeroOrOne\
A.Nav is not nullable & B.Nav is nullable\
Multiplicity = ZeroOrOne & Multiplicity = One\
A.Nav is not nullable & B.Nav is not nullable\
Multiplicity = One & Multiplicity = One\

