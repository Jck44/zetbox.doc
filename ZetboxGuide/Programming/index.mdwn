Programming
===========

This chapter describes the various ways and pieces the Zetbox system is
programmed and customized.

Objects
-------

### ObjectClass

Zetbox knows four kinds of Types, all derived from *DataType*:

ObjectClass
:   Type for Zetbox Object Classes

Interface
:   Type for Zetbox Interfaces

Enumeration
:   Type for Zetbox Enumerations

CompoundObject
:   Type for Zetbox Object Classes

#### DataType

This is the abstract base class for all Zetbox Types. It provides the
necessary infrastructure to describe a Type.

public interface DataType

string Name; string Description;

IList\<Property\> Properties; ICollection\<Method\> Methods;
ICollection\<MethodInvocation\> MethodInvocations;

Icon DefaultIcon; ICollection\<InstanceConstraint\> Constraints;

Name
:   The name of the *DataType*. Note that this name has to be a valid
    C\# name. A *Constraint* protects this.

Description
:   Each Type should have a description. This description is used for
    documentation purposes.

Properties
:   Each Type can have Properties (except *Enumeration*)

Methods
:   Each Type can have Methods (except *Enumeration*)

MethodInvocations
:   Methods on a *DataType* are invoked by an MethodInvokation. It does
    not matter on which level of type hierarchy the invokation is
    defined.

DefaultIcon
:   Each *DataType* can have a default icon

Constraints
:   A *Constraint* checks the validity of an instance. If any constraint
    throws an error nothing will be committed.

#### ObjectClass

*ObjectClass* is *the* defining class for Zetbox Objects.

public interface ObjectClass : DataType

ObjectClass BaseObjectClass; ICollection\<Interface\>
ImplementsInterfaces;

string TableName;

bool IsAbstract; bool IsFrozenObject; bool IsSimpleObject;

ViewModelDescriptor DefaultViewModelDescriptor; ControlKind
RequestedKind;

ICollection\<AccessControl\> AccessControlList;

IsAbstract
:   
IsSimpleObject
:   The *ObjectClass* is marked as a simple, non complex object. Set it
    to true for all classes that have no inheritance and less enought
    and simple properties to edit them in grids and/or lists. This will
    prevent all list view models from opening such an object directly.
    Also the *ObjectBrowser* will not provide any interface.

* [[Relations]]
	
### Properties

public interface Property string Name; ...

Editable in Grid
:   This is an override for the inline editing behaviour for grid and
    list controls. The default behaviour is to evaluate if the
    referenced *ObjectClass* is a simple object or not.

### Additional Metadata

The object model is intended to be very rich and provide the various
subsystems with meta data directly from the *ObjectClass*.

This section describes the various pieces of this meta data.

#### New related objects

A *CreateRelatedUseCase* describes the use case of creating a new object
related to the "current" instance. One such use case would be
e.g. "create a new *Relation* from the current ObjectClass."

Such use cases are described with *CreateRelatedUseCase* objects:

interface CreateRelatedUseCase string Label; Method Action; Relation
AffectedRelation; // optional

The *Action* will be called when the user requests an execution of this
use case. This method doesn’t take any parameters and returns the newly
created object. The infrastructure on the client will cause the returned
object to be displayed to the user. The business logic should already
have filled out the property values according to the use case. The name
of the method should start with "Create".

If the optional *AffectedRelation* is specified, one of its ends it must
match the *ObjectClass* of the *Method*. This relation can then be used
to identify controls in the UI where the action can be placed.

Modules
-------

Compound Objects
----------------

Lets say there is a *PhoneNumber* Compound Object.

class PhoneNumber string CountryCode; string AreaCode; string Number;
string Extension;

A Person has two phone numbers:

class Person string Name; ... PhoneNumber Tel; PhoneNumber? Fax;

*Tel* is not nullabe, *Fax* is nullable.

### Accessing Compound Objects

-   If a compound object property is not nullable then the content of
    the property is always a valid reference.

-   If a compound object property is nullable then the content of the
    property may be null.

-   When a compound object property is set the given compound object
    will be copied.

Person p; string number;

number = p.Tel.Number; number = p.Fax.Number; // throws
NullReferenceException if Fax is null

p.Tel.Number = "12345678"; p.Fax.Number = "12345678"; // throws
NullReferenceException if Fax is null

PhoneNumber n;

n = p.Tel; // returnes a reference of the compound object n.Number =
"87654321"; // changes p.Tel.Number n = p.Fax; // may be null n.Number =
"87654321"; // changes p.Fax.Number or throws NullReferenceException if
Fax is null

p.Fax = p.Tel; // creates a copy of p.Tel p.Fax.Number = "87654321"; //
changes p.Fax.Number but does not change p.Tel.Number

p.Tel = null; // throws a ArgumentNullException p.Fax = null; // sets
Fax to null

n = ctx.CreateStruct\<PhoneNumber\>(); // creates a new PhoneNumber
Struct; n.Number = "12345678"; p.Tel = n; // creates a copy of n
p.Tel.Number = "18273645"; // changes p.Tel.Number but does not change
n.Number n.Number = "87654321"; // changes n.Number but does not change
p.Tel.Number

Enhancing Zetbox’s inner workings
---------------------------------

### Database Providers

[[GraphicalUserInterface]]

Concurrency
-----------

Zetbox supports optimistic concurrency. It’s enabled, when a
*ObjectClass* implements the *IChangedBy* interface. The versioning
column is *ChangedOn*.

Core Zetbox Development Environment
-----------------------------------

### Preparing a clean local build

First, it is necessary to have a clean build environment. Use *subst* to
create a drive *P:* where your checkout resides in a directory called
*Zetbox*.

The *!FullReset.cmd* will bring the database and the bootstrapping code
up to the current *Database.xml*’s content.

Now the environment is ready for programming.

### Merging local and remote changes

When the subversion repository has changed the *Database.xml* while
local changes were made to the schema, it is necessary to merge them
before comitting.

After fetching and merging the update from the subversion repository,
the local *Database.xml* has changes which are not yet in the database.
Running *!DeployAll.cmd* updadates the SQL-schema and produces a new set
of generated assemblies in the *CodeGenPath*. After testing that the
merge was successful, use *GetCodeGen.cmd* to update the working
directory with the newly generated bootstrapping code.

Now the working directory is ready for check in.
